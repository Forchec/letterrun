<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Letter Run - Test Stage</title>
    <script type="text/javascript" src="js/lib/jquery-1.11.1.min.js" ></script>
    <!-- <script>
      $(function(){ $("head").load("/../Fixed/header.html") });
    </script> -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>

    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

//alert("Test Stage is called")

var config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 300 },
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

var player;
// var stars;
var letters;
var bombs;
var enemys;
var platforms;
var cursors;
var gameOver = false;


var WORD = "letterrun"; // check with repeated letter
var WORD_LEN = WORD.length;

var letterBoard = [];
var alpha = "abcdefghijklmnopqrstuvwxyz";
var x_for_board;
var tmp;
var retmp;
var letter = '';
var i = 0;
var door;
var visitChecker = []
for (var i = 0; i < WORD_LEN; i++){
  visitChecker.push("");
}


var game = new Phaser.Game(config);

function preload ()
{
    var current = '';
    for (var i = 0; i < 26; i++) {
      current = alpha.charAt(i);    // Collectable letters
      this.load.image(current, '../assets/' + current + '.png');
      current = alpha.charAt(i) + alpha.charAt(i);  // Color-box letters
      this.load.image(current, '../assets/' + current + '.png');
      current = alpha.charAt(i) + alpha.charAt(i) + alpha.charAt(i); // Gray-box letters
      this.load.image(current, '../assets/' + current + '.png');
    }
    this.load.image('door', '../assets/door.png');
    this.load.image('sky', '../assets/sky.png');
    this.load.image('ground', '../assets/platform.png');
    this.load.image('bomb', '../assets/bomb.png');
    //this.load.spritesheet('enemy', '../assets/enemy.png',{frameWidth: 64, frameHeight: 64});
    this.load.spritesheet('dude', '../assets/dude.png', { frameWidth: 32, frameHeight: 48 });
    this.load.spritesheet('testEnemy', '../assets/dude.png', { frameWidth: 32, frameHeight: 48 });

}

function create ()
{
    //  A simple background for our game
    this.add.image(400, 300, 'sky');

    // Display initial board (grayed-out version)
    for(i = 0; i < WORD_LEN; i++){
      x_for_board = 25 + (50 * i);
      letter = WORD.charAt(i) + WORD.charAt(i) + WORD.charAt(i);
      tmp = this.add.sprite(x_for_board, 25, letter);
      tmp.setDisplaySize(40, 40);
    }

    door = this.physics.add.sprite(700, 140, 'door');

    door.setDisplaySize(80, 126); // 70 110


    //  The platforms group contains the ground and the 2 ledges we can jump on
    platforms = this.physics.add.staticGroup();
this.physics.add.collider(door, platforms);
    //  Here we create the ground.
    //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
    platforms.create(400, 568, 'ground').setScale(2).refreshBody();


    //  Now let's create some ledges
    platforms.create(600, 400, 'ground');
    platforms.create(50, 250, 'ground');
    platforms.create(750, 220, 'ground');

    // The player and its settings
    player = this.physics.add.sprite(100, 450, 'dude');

    //enemys
    this.anims.create({
      key: 'enemyMove',
      frames: this.anims.generateFrameNumbers('testEnemy',{start:0, end:4}),
      frameRate: 10,
      repeat: -1
    })

    enemies = this.physics.add.group({
      key:'testEnemy',
      repeat: 1,
      setXY: {x:750, y:170, stepX: -150, stepY: 150}
    })
    enemies.children.iterate(function (child) {
        //  make enemy move
        child.anims.play('enemyMove',true);
        //Set speed randomly
        child.setTint(0x5e92e5);
        child.setVelocityX(Math.floor(Math.random()*( -20 + 1)) + -50);
        child.body.allowGravity =false;
        //console.log(child.body)
        child.body.setSize(13,13,2,2);
        child.body.immovable = true;
        child.setCollideWorldBounds(true);
    //    child.body.onWorldBounds =true;
      //  child.addListener("onOutOfBounds",()=>{console.log("hello")});
    });



    //  Player physics properties. Give the little guy a slight bounce.
    player.setBounce(0.2);
    player.setCollideWorldBounds(true);

    //  Our player animations, turning, walking left and walking right.
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'turn',
        frames: [ { key: 'dude', frame: 4 } ],
        frameRate: 20
    });

    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
    });

    // this.anims.create({
    //   key: 'enemyMove',
    //   frams: this.anims.generateFrameNumbers('enemy',{start:1, end:6}),
    //   frameRate: 20,
    //   repeat: -1
    // })

    //  Input Events
    cursors = this.input.keyboard.createCursorKeys();

//////imimimimportante finish by this week///////////////// - random letter random pos
  for (i = 0; i < WORD_LEN + 10; i++){
    // array for x and y
  }
  var x = Math.floor(Math.random() * 700) + Math.floor(Math.random() * 50);
  var y = Math.floor(Math.random() * 400);
  console.log(x);
  console.log(y);
  // Display neccessary letters (letters to make the word)
  for (i = 0; i < WORD_LEN; i++){
    tmp = WORD.charAt(i);
    letters = this.physics.add.sprite(x, y, tmp);
    if (tmp == 'w'){
      letters.setDisplaySize(50, 50);
    }
    else{
      letters.setDisplaySize(40, 40);
    }
    this.physics.add.collider(letters, platforms);
    this.physics.add.collider(letters, letters);
    this.physics.add.overlap(player, letters, collectLetter, null, this);
    //this.physics.add.overlap(player, enemy, letterAway, null, this);
    letters.myName = tmp;
    x = Math.floor(Math.random() * 700) + Math.floor(Math.random() * 50);
    y = Math.floor(Math.random() * 400);
  }

  // Display random letters
    for (i = 0; i < 8; i++){
      tmp = chooseRandomLetter(alpha);

      // var xx = Math.floor(Math.random());
      // var yy = Math.floor(Math.random());
      letters = this.physics.add.sprite(x, y, tmp);
      if (tmp == 'w'){
        letters.setDisplaySize(50, 50);
      }
      else{
        letters.setDisplaySize(40, 40);
      }
      this.physics.add.collider(letters, platforms);
this.physics.add.collider(letters, letters);
      this.physics.add.overlap(player, letters, collectLetter, null, this);
      letters.myName = tmp;
      x = Math.floor(Math.random() * 700) + Math.floor(Math.random() * 50);
      y = Math.floor(Math.random() * 400);
    }
/////////////////////////////////////////////////////////

    bombs = this.physics.add.group();

    //  Collide the player with the platforms
    this.physics.add.collider(player, platforms);

    this.physics.add.collider(bombs, platforms);
    this.physics.add.collider(enemies, platforms);



    //  Checks to see if the player overlaps with any of the letters, if he does call the collectLetter function
    this.physics.add.overlap(player, letters, collectLetter, null, this);

    //this.physics.add.collider(player, enemy, hitEnemy, null, this);

    this.physics.add.collider(player, bombs, hitBomb, null, this);
    this.physics.add.collider(player, enemies, enemyCollision, null, this);

    // enemy.setVelocityX(160);
    // enemy.anims.play('enemyMove', true);


    this.physics.add.overlap(player, door, hitDoor, null, this);
}

function update ()
{
    if (gameOver)
    {
        return;
    }

    if (cursors.left.isDown)
    {
        player.setVelocityX(-160);

        player.anims.play('left', true);
    }
    else if (cursors.right.isDown)
    {
        player.setVelocityX(160);

        player.anims.play('right', true);
    }
    else
    {
        player.setVelocityX(0);

        player.anims.play('turn');
    }

    if (cursors.up.isDown && player.body.touching.down)
    {
        player.setVelocityY(-330);
    }
}

function chooseRandomLetter(str){
  var index = Math.floor(Math.random() * str.length);
  var ret = '';
  ret += str.charAt(index);
  return ret;
}

function collectLetter(player, letter)
{

  letter.disableBody(true, true);

  var cur = '';
  for (i = 0; i < WORD_LEN; i++){
    if (letter.myName === WORD.charAt(i)){
      if (visitChecker[i] != "visited"){
      x_for_board = 25;
      cur = WORD.charAt(i) + WORD.charAt(i);
      x_for_board = x_for_board + (50 * i);
      tmp = this.add.sprite(x_for_board, 25, cur);
      tmp.setDisplaySize(40, 40);
      visitChecker[i] = "visited";
      break;
    }
    else{
      continue;
    }

      letterBoard.push(letter.myName);
    }
  }

  // if (letters.countActive(true) === 0)
  // {
  //     letters.children.iterate(function (child) {
  //     child.enableBody(true, child.x, 0, true, true);
  // });
  //     var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);
  // }
}

function hitBomb (player, bomb)
{
    this.physics.pause();

    player.setTint(0xff0000);

    player.anims.play('turn');

    gameOver = true;
}

// function hitEnemy (player, enemy){
//   if (letterBoard.isEmpty()){
//     this.physics.pause();
//
//     player.setTint(0xff0000);
//
//     player.anims.play('turn');
//
//     gameOver = true;
//   }
//   else{ // Doesn't work
//     var rand = chooseRandomLetter(WORD);
//     var lenn = letterBoard.length;
//     for (i = 0; i < lenn; i++){
//       if (rand === letterBoard[i]){
//         letterBoard.splice(i, 1);
//         i+=1000000;
//       }
//
//     }
//
//     var index = 0;
//     while (rand !== WORD.charAt(index)){
//       index++;
//     }
//     x_for_board = 25 + (50 * index);
//     rand = rand + rand + rand;
//     tmp = this.add.sprite(x_for_board, 25, rand);
//     tmp.setDisplaySize(40, 40);
//   }
// }

function hitDoor (player, door)
{
  var cond = true;
  for (var i = 0; i < WORD_LEN; i++){
    if (visitChecker[i] != "visited"){
      cond = false;
    }
  }
  if (cond === true){
    this.physics.pause();
    player.anims.play('turn');
    gameOver = true;
  }

  // var len = letterBoard.length;
  // for (i = 0; i < len; i++){
  //   for (var j = 0; j < WORD_LEN; j++){
  //     if (letterBoard[i] === word.charAt(j)){
        // this.physics.pause();
        //
        // player.anims.play('turn');
  //
  //       gameOver = true;
  //     }
  //   }
  // }

}

function enemyCollision(player, enemy){
   alert("eneterd");
//  enemy.disableBody(true, true);
  //throwLetter();
}

</script>

</body>
</html>
